{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useReducer, useRef } from 'react';\nimport { HTTP } from 'shared/lib/http';\n\n/**\n * Cache store\n */\n\n/**\n * Statuses fetches\n */\nexport let FetchStatus = /*#__PURE__*/function (FetchStatus) {\n  FetchStatus[\"Loading\"] = \"loading\";\n  FetchStatus[\"Error\"] = \"error\";\n  FetchStatus[\"Success\"] = \"success\";\n  return FetchStatus;\n}({});\n\n/**\n * State of hook\n */\n/**\n * Type for action for reducer\n */\nvar ActionType = /*#__PURE__*/function (ActionType) {\n  ActionType[\"Load\"] = \"load\";\n  ActionType[\"Error\"] = \"error\";\n  ActionType[\"Success\"] = \"success\";\n  return ActionType;\n}(ActionType || {});\n/**\n * Action of loading\n */\n/**\n * Action success of loading\n */\n/**\n * Action error of loading\n */\n/**\n * Actions for state reducer\n */\n/**\n * Options for fetching \n */\n/**\n * Reducer for changing state fetch state\n * @param state prev state\n * @param action dispatched action\n * @returns new state\n */\nfunction reducer(state, action) {\n  switch (action.type) {\n    default:\n    case ActionType.Load:\n      return {\n        ...state,\n        status: FetchStatus.Loading\n      };\n    case ActionType.Success:\n      return {\n        ...state,\n        data: action.payload,\n        status: FetchStatus.Success\n      };\n    case ActionType.Error:\n      return {\n        ...state,\n        status: FetchStatus.Error,\n        error: action.payload\n      };\n  }\n}\nexport const useFetch = (url, options) => {\n  _s();\n  const {\n    useCache = true\n  } = options !== null && options !== void 0 ? options : {};\n  const cache = useRef({});\n  const [state, dispatch] = useReducer(reducer, {});\n  useEffect(() => {\n    dispatch({\n      type: ActionType.Load\n    });\n    if (useCache && cache.current[url]) {\n      dispatch({\n        type: ActionType.Success,\n        payload: cache.current[url]\n      });\n      return;\n    }\n    const controller = new AbortController();\n    HTTP.get(url, {\n      signal: controller.signal\n    }).then(response => {\n      cache.current[url] = response;\n      if (controller.signal.aborted) {\n        return;\n      }\n      dispatch({\n        type: ActionType.Success,\n        payload: response\n      });\n    }).catch(e => {\n      if (controller.signal.aborted) {\n        return;\n      }\n      dispatch({\n        type: ActionType.Error,\n        payload: e\n      });\n    });\n    return () => controller.abort();\n  }, [useCache, url]);\n  return state;\n};\n_s(useFetch, \"BP5cdC0mLIPd276S1JUKwUGu1kI=\");","map":{"version":3,"names":["useEffect","useReducer","useRef","HTTP","FetchStatus","ActionType","reducer","state","action","type","Load","status","Loading","Success","data","payload","Error","error","useFetch","url","options","_s","useCache","cache","dispatch","current","controller","AbortController","get","signal","then","response","aborted","catch","e","abort"],"sources":["/Users/creator/Documents/projects/Israel-project/client/src/shared/hooks/useFetch.ts"],"sourcesContent":["import { Reducer, useEffect, useReducer, useRef } from 'react';\nimport { HTTP } from 'shared/lib/http';\n\n/**\n * Cache store\n */\ninterface ICache {\n  [url: string]: unknown;\n}\n\n/**\n * Statuses fetches\n */\nexport enum FetchStatus {\n  Loading = 'loading',\n  Error = 'error',\n  Success = 'success'\n}\n\n/**\n * State of hook\n */\nexport interface IState<T> {\n  data?: T;\n  status?: FetchStatus;\n  error?: Error;\n}\n\n/**\n * Type for action for reducer\n */\nconst enum ActionType {\n  Load = 'load',\n  Error = 'error',\n  Success = 'success'\n}\n\n/**\n * Action of loading\n */\ninterface ILoadAction {\n  type: ActionType.Load;\n}\n\n/**\n * Action success of loading\n */\ninterface ISuccessAction {\n  type: ActionType.Success;\n  payload: unknown;\n}\n\n/**\n * Action error of loading\n */\ninterface IErrorAction {\n  type: ActionType.Error;\n  payload: Error;\n}\n\n/**\n * Actions for state reducer\n */\ntype TActions = ILoadAction | ISuccessAction | IErrorAction;\n\n/**\n * Options for fetching \n */\nexport interface IFetchOptions {\n  /**\n   * Flag for using cash on time of hook living\n   */\n  useCache?: boolean;\n}\n\n/**\n * Reducer for changing state fetch state\n * @param state prev state\n * @param action dispatched action\n * @returns new state\n */\nfunction reducer<T>(state: IState<T>, action: TActions): IState<T> {\n  switch (action.type) {\n    default:\n    case ActionType.Load:\n      return { ...state, status: FetchStatus.Loading}\n    case ActionType.Success:\n      return { ...state, data: action.payload as T, status: FetchStatus.Success }\n    case ActionType.Error:\n      return { ...state, status: FetchStatus.Error, error: action.payload }\n  }\n}\n\nexport const useFetch = <TData>(url: string, options?: IFetchOptions): IState<TData> => {\n  const {\n    useCache = true\n  } = options ?? {};\n  const cache = useRef<ICache>({});\n  const [state, dispatch] = useReducer<Reducer<IState<TData>, TActions>>(reducer<TData>, {});\n\n  useEffect(() => {\n    dispatch({ type: ActionType.Load });\n\n    if (useCache && cache.current[url]) {\n      dispatch({ type: ActionType.Success, payload: cache.current[url] });\n      return;\n    }\n\n    const controller = new AbortController();\n\n    HTTP.get<TData>(url, { signal: controller.signal })\n      .then((response) => {\n        cache.current[url] = response;\n        if (controller.signal.aborted) {\n          return;\n        }\n        dispatch({ type: ActionType.Success, payload: response });\n      })\n      .catch((e) => {\n        if (controller.signal.aborted) {\n          return;\n        }\n        dispatch({ type: ActionType.Error, payload: e })\n      });\n\n    return () => controller.abort();\n  }, [useCache, url]);\n\n  return state;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}